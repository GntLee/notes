----------------------
Javascript运行机制
----------------------
	# 为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

	# 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程
		* 子线程完全受主线程控制，且不得操作DOM
		* 这个新标准并没有改变JavaScript单线程的本质
	
	

	# 任务队列
		* 任务有2种：
			- 同步任务（synchronous）
			- 异步任务（asynchronous）
		
		* 同步任务，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
		* 异步任务，不进入主线程、而进入"任务队列"（task queue），只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行
		
		* 整个过程
			1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
			2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
			3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
			4. 主线程不断重复上面的第三步。

		* 只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。
	
	# 事件和回调函数
		* "任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。
		* 只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。
	
		* "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取
		* 主线程的执行栈一旦清空（执行完毕），"任务队列"上第一位的事件就自动进入主线程
		* 如果'事件'是定时器的话，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程被执行
	
	# Event Loop
		* 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop

		* 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（click，load，done）。
		* 只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。
	
	# 定时器
		* setTimeout()和setInterval()这两个函数差不多
		* 这俩方法，都是在"任务队列"的'尾部'添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。

		* 所以，setTimeout()/setInterval()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。
		* 要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在指定的时间执行

		* HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加
		* 在此之前，老版本的浏览器都将最短间隔设为10毫秒



	# 总结
		* 就俩：执行栈和任务队列
		* js的主线程挨着处理执行栈中的任务，这些任务可能会产生一些异步的任务。全部推送到 任务队列。
		* 执行栈的任务处理完了，就开始轮询任务队列，挨个处理那些可以处理的异步任务。
		
		* 定时器也是当作异步任务，丢到 任务队列的最后面去执行