
# 2进制转换为10进制
	* 从二进制的右往左,依次列为第0,1,2...位,第n位的数(0或1)乘以2的n次方 
	* 把最终的结果相加

	110101101

	1 x 2 的 0 次方 = 1
	0 x 2 的 1 次方 = 0
	1 x 2 的 2 次方 - 4
	1 x 2 的 3 次方 = 8
	0 x 2 的 4 次方 = 0
	1 x 2 的 5 次方 = 32
	0 x 2 的 6 次方 = 0
	1 x 2 的 7 次方 = 128
	1 x 2 的 8 次方 = 256

	256 + 128 + 32 + 8 + 4 + 1 = 429

# 10进制转换为2进制

	358

	358 % 2 = 0 (358 // 2 = 179)
	179 % 2 = 1 (179 // 2 = 89 )
	89  % 2 = 1 (89  // 2 = 44 )
	44  % 2 = 0 (44  // 2 = 22 )
	22  % 2 = 0 (22  // 2 = 11 ) 
	11  % 2 = 1 (11  // 2 = 5  )
	5   % 2 = 1 (5   // 2 = 2  )
	2   % 2 = 0 (2   // 2 = 1  )
	1   % 2 = 1 (1   // 2 = 0  )

	101100110

# 2进制转换为8进制
	* 把二进制每三位分开,最后一组,不足三位前面补0
	* 计算出每组的值(8进制),连接起来,就是最终的八进制结果

	11011011010101
	
	011 011 011 010 101
	3   3   3   2   5

	33325

# 8进制转换为2进制
	* 把8进制每一位都转换为2进制后拼接,不足三位补0
	
	33325

	3	3	3	2	5
	011	011	011	010	101

	11011011010101


# 2进制转换为16进制
	* 把二进制每四位分开,最后一组,不足三位前面补0
	* 计算出每组的值(16进制),连接起来,就是最终的十六进制结果
	
	10110110110

	0101 1011 0110
	5	 B	  6
	
	0x5B6
	
# 16 进制转换为 2 进制
	* 把16进制的每一位都转换为2进制后拼接,不足四位补0

	0x5B6

	5		B		6
	0101	1011	0110

	10110110110


# 计算机以补码形式存储数据(主要是为了解决负数的存储问题)
	

	* 原码
		- 原始的二进制
		- 用户的数字分为正负数,符号位的存储
		- 最高位为符号位,0 表示正数, 1 表示负数
			0000 0001		+1
			1000 0001		-1

			0000 0000		+0
			1000 0000		-0
		- 原码存储导致两个问题
			1,0有两种存储方式,+0,-0
			2,正数和负数相加,结果不对
				* 计算机只会加,不会减

				1 + -1 = 0(1 - 1)
				
				0000 0001	+1
				1000 0001	-1	
				---------	相加
				1000 0010	-2	(错误的结果, (+1) + (-1) 结果应该是0)


	* 反码
		- 正数的反码,就是原码,不能改变
		- 为了算补码
		- 负数在原码基础上符号位不变,其他位取反(0变1,1变0)
			0000 0001	+1
			1000 0001	-1
			0000 0000	+0
			1000 0000	-0
					反码
			0000 0001	+1
			1111 1110	-1
			0000 0000	+0
			1111 1111	-0
		
		- 反码存在解决了正负相加结果不正确的问题
				0000 0001	+1
				1111 1110	-1	
				---------	相加
			    1111 1111	-0	(正确的结果, (+1) + (-1) 结果应该是-0	(+0,-0都是0,两种0因为引发了下面的问题))

		- 反码存储有一个问题
			1,0存储有两种方式
				

	* 补码
		- 计算机存储数字是以补码方式存储
		- 正数的原码,反码,补码都一样
		- 负数的补码,就是其反码 + 1
			0000 0001	+1
			1000 0001	-1
			0000 0000	+0
			1000 0000	-0
				反码
			0000 0001	+1
			1111 1110	-1
			0000 0000	+0
			1111 1111	-1
				补码
			0000 0001	+1
			1111 1111	-1
			0000 0000	+0
		   10000 0000	-0 (使用1个字节存储,大小超出了之后,最高位丢弃,最终的结果就是 0000 0000)

		- 补码运算
			0000 0001	+1
			1111 1111	-1
			------------相加
		   1000 00000	+0 (使用1个字节存储,大小超出了之后,最高位丢弃,最终的结果就是 0000 0000)


	* 原码求补码
		- 计算出原码的反码
		- + 1

	* 补码求原码
		- 计算出补码反码 
		- + 1



	#include<stdio.h>
	#include<stdlib.h>

	int main(void) {

		//-1的二进制
		int bin = 0b10000001;
		/*
			1000 0001
			8    1
			-------
			0x81
		*/
		char hex = 0x81;
		
		printf("%d\n",hex);     // -127

		/*
			10000001
				反码(符号位不动,取反)
			1111 1110
				补码(+1)
			1111 1111   (-127)
			======= 补码求原码  =====
			1111 1111
				取补码的反码
			1000 0000
				反码 + 1
			1000 00001
		*/
		return EXIT_SUCCESS;
	}



