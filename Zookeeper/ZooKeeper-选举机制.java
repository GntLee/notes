
----------------------------
选举机制					|
----------------------------
	# ZK默认的算法是: FastLeaderElection 
		* 采用投票数大于半数胜出的机制

	# 服务器id
		* 集群有3台服务器,编号为:1,2,3
		* 编号越大在选择算法中权重越大

	# 选举状态
		LOOKING 竞选状态

		FOLLOWING 随处状态,同步Leader状态,参与投票

		OBSERVER 观察状态,同步Leader状态,不参与投票

		LEADING 领导者状态

	# 数据id
		* 服务器中存放的最新数据Version
		* 哪个节点的最新数据Version值越大,说明数据越新,在选举算中数据权重越大

	# 逻辑时钟
		* 也叫做投票次数
		* 同一轮投票过程中的逻辑时钟值是相同的,每投完一次票,这个数据就会增加
		* 然后与接收到的其他服务器返回的投票信息中的数值相比
		* 根据不同的数值做出不同的判断



----------------------------
全新集群的选举				|
----------------------------
	# 假设有5台服务器
		* 每台服务器都没有数据,编号为:1,2,3,4,5
		* 按照编号依次启动
	
	# 选举过程如下
		1,服务器1启动,给自己投票,然后发投票信息
			* 其他机器还没启动,所以它没收到反馈,于是一直处于 LOOKING

		2,服务器2启动,给自己投票,同时与服务器1交换结果
			* 由于服务器2的编号大于服务器前面的服务器,所以服务器1会把自己的票给服务器2
			* 服务器2胜出,它有2票
			* 但此时投票数没有大于半数(2 < (5/2)),所以两个服务器依然是 LOOKING
		
		3,服务器3启动,给自己投票,同时与服务器1,2交换信息
			* 由于服务器3的编号最大,所以服务器3胜出,得到了服务器1,和2的票
			* 服务器3胜出,它有 3 票
			* 此时投票数正好大于半数(3 > (5 / 2)),所以服务器3成为Leader,服务器1,2成为 Leader
		
		4,服务器4启动,给自己投票,同时与之前启动的服务器1,2,3交换信息
			* 虽然服务器4最大,但是之前服务器3已经胜出,所以服务器4只能是 Follower
		
		5,服务器5启动,后面的逻辑跟服务器4一样,也是 Follower
			
		
		* 每个服务器都给自己投票
		* 投票数过半选举结束
	
	
	# 全新集群的重要依据就是服务器的编号,也就是myid

----------------------------
非全新集群的选举			|
----------------------------
	# 正常运行的ZK集群中,有节点宕掉,需要重新选举
	# 选举的过程就需要:数据id,服务器id,逻辑时钟

	# 数据id
		* 服务器的数据越新, Version值就越大
	
	# 服务器id

	# 逻辑时钟	
		* 这个值从0开始递增,每次选举对应一个值,在同一次选举中,这个值是一致的
		* 第一次选举值为0,服务器1参加了选举
		* 服务器1宕掉,集群再次选举,这时其他参与选举逻辑时钟值为1(递增 )
		* 服务器1重新加入集群,因为其他节点宕掉,参与选举,因为它宕机没有参加第一次的选举,所以它的逻辑时钟值还是为0,没有得到自增

	
	# 规则
		1,逻辑时钟小的选举结果被忽略,重新投票(上次宕机或者其他原因,没参加选举)
			* 状态最稳
		2,统一逻辑时钟后,数据id大的胜出
			* 数据最新
		3,数据id相同情况下,服务器id大的胜出
			* 服务器id最大