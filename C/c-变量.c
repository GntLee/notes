

----------------------------------------
变量									|
----------------------------------------
	# 变量的类型与内存大小
		char
			* 字符型,使用单引号声明,用于输出一个单一的字符
			* 1个字节
			* 它并不是把字符存储到内存单元,而是把字符对应的 ascii 编码存放到存储单元
			* 本质上就是一个字节的整形,下面两种声明方式都是正确的
				char c = 97;
				char c = 'a';
			* 花里胡哨
				printf("%d\n",'\023');      //\0开头表示八进制      19
				printf("%d\n",'\x15');      //\x开头表示十六进制    21
				printf("%d\n",'\0');        //\0还是0

		short
			* 短整型,2字节
		int
			* 整形,4字节
		long
			* 长整型
			* windows4字节
			* linux4字节(32位),8字节(64位)
		long long
			* 长长整型
			* 8字节
		
		float
			* 单精度浮点型
			* 4字节,7位有效数字
			* 1位符号,8位指数,23位小数
		

		double
			* 双精度浮点型
			* 8字节,15 - 16 位有效数字
			* 双精度浮点值,双精度是1位符号,11位指数,52位小数

		long double
			* 16字节

	

		unsigned
		signed
		
		void
			* 不可以定义 void 类型的普通变量,编译器不知道它是什么类型,无法分配内存空间
			* 但是可以定义 void 指针,因为指针的大小是可以确定的(传说中的万能指针)

		_Bool
		_Complex
		_Imaginary

		* 整形数据在内存中占的字节与所选择的OS有关
		* C标准并没有明确规定整形类型数据的长度,但 long 的长度不能低于 int, int 不能低于 short
		* 占位小的数据赋值给占位大的数据,没有问题,系统会有变量提示
		* 占位大的数据赋值给占位小的数据,会发生高位截断从而引发精度丢失的问题

		* 浮点类型变量是由有限的存储单元组成,因此只能提供有限的有效数字
		* 不在有效范围的数字将会被舍去,这样可能会产生一些误差
	
	
	# 常量默认类型
		* 数字通常以 int 类型表示,如果超出了 int 类型,编译器会先视其为 long int 类型
		* 如果超出了 long 可表示的最大值,编译器则视其为 unsigned long 类型
		* 如果还不不够大,编译器则将其视为 long long 或者 unsigned long long 类型
		* 前提是编译器能够识别这些类型
	
		* 八进制,十六进制也被视为 int 类型
		* 如果值太大,编译器会尝试使用 unsigned int ,long ,unsigned long ,long long ,unsigned long 类型
		
	
	# 指定常量数据类型
		* 在值后面添加L/l表示该常量是 long 数据类型
			15L;
		
		* 在职后天添加LL/ll表示该常量是 long long 数据类型
			15LL

		* 添加f/F后缀,是 float 的常量声明
			0.23F

		* 添加 u/U后缀 是 unsgined 常量类型声明
			5u
			5UL
			5ULL
		
		* 添加0b前缀,是二进制数据类型
			0B0101101
		
	
----------------------------------------
变量修饰符								|
----------------------------------------
	const
		* 常量

	volatile
		* 防止编译器优化代码
	
	restrict
		* 允许编译器优化某部分代码,以更好的支持运算,它只能用于指针
		* 表名该指针是访问数据对象唯一且初始化的方式

	extern
		* 声明一个变量,extern 生的变量没有建立存储空间
			extern int x;
		* 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候
	
	register
		* 定义寄存器变量,提高效率,register 是建议类型的指令,而不是命令类型的指令
		* 如果 CPU 有空闲的寄存器,那么 register 生效,反之 register 无效
		* 这种类型的变量,不能使用取地址符 & ,因为无法获取,该变量在CPU寄存器
			
	
	auto 
		* 局部变量修饰
		* 在函数内部的变量 int a = 10; 编译器会有 int a = 10 之前会加上auto的关键字
		* auto的出现意味着,当前变量的作用域为当前函数或代码段的局部变量,意味着当前变量会在内存栈上进行分配

	static
		* 静态变量修饰


----------------------------------------
类型转换								|
----------------------------------------
	# 显式转换
		* 大转小
			int num = 255;
			short s = (short)num;
		* 使用括号来完成强制转换,可能引发精度丢失的问题


	# 隐式转换
		* 小转大
			double a;
			int b = 0;
			a = b;			//编译器自动把b的值转换为double,在给a赋值

----------------------------------------
bool 类型								|
----------------------------------------
	# C语言中使用 0 表示 false,非 0 表示 true
	# C99提供了 #include<stdbool.h> 头文件,使C增加了 bool 关键字和 true / false 关键字
		bool flag = true;
		flag = false;

----------------------------------------
常量声明								|
----------------------------------------
	# 编译时替换常量
		#define name value

		* 在编译程序的时候,程序中的所有 name 都会被替换为 value
		* 这个过程称为编译时替换,在运行程序的时候,所有替换都已经完成
		* 这样定义的常量也被称为明示常量

		* 末尾不需要添加;,而且名称要大写
	
	# const 
		const int X = 5;

		* X 这个变量只读,不能修改


----------------------------------------
typedef 机制							|
----------------------------------------
	# typedef 机制允许开发者为现有的数据类型创建别名
		typedef char byte;
		/*
			1111 1111 源码
			1000 0000 反码
			1000 0001 补码
		*/
		byte x = 255;
		printf("%d",x);	//-1
	

----------------------------------------
可移植类型 stdint.h 和 inttypes.h		|
----------------------------------------
	//TODO



	

----------------------------------------
局部变量								|
----------------------------------------
	# 普通局部变量
		* 声明在代码块{}内部的变量,只能在{}内部使用,在{}外部,不能访问{}内部中的局部变量
		* 局部变量和全局变量的名称可以相同,但是在函数内,局部变量的值会覆盖全局变量的值
		* 局部变量也叫 auto 变量(auto 可以省略不不写编译器会自动的添加,它只能出现在{}内部)
		* 如果没有初始化赋值,那么默认值为随机(垃圾数据)
		* 只有执行到该变量的定义语句,才会分配内存空间,{}代码块结束后,内存释放
	
	# static 局部变量
		* 在{}中使用 static 修饰的局部变量
		* 静态的局部变量,在编译阶段就已经分配了空间,函数在调用前,就已经初始化,且仅仅只会执行这一次初始化(但是可以重复的赋值多次)
		* 静态局部变量不会释放,只有程序结束,所有静态变量才会自动释放
		* 在{}之外,不能访问{}中的静态变量
		* 如果静态变量未初始化,那么它的默认值为:0

		* 静态变量,存在于 data 区,在程序未启动,就已经初始化了值
		* 只能用常量初始化,不能使用变量(变量还未初始化,常量就已经初始化了)
			int y = 0;
			static int x = y;	//error

----------------------------------------
全局变量								|
----------------------------------------
	# 普通全局变量(外部链接)
		* 定义在函数外部的变量,称之为全局变量
		* 在任何地方,都能使用这个全局变量
		* 全局变量,在编译时,就已经分配了内存,只有在整个程序结束,才会释放
		* 如果全局变量定义在了执行函数的后面,那么需要先使用 extern 声明,如果只有 extern 声明,没有定义,那么会异常
			#include <stdlib.h>
			#include <stdio.h>
			//初始化局部变量
			int y = 5;
			int main(int argc,char **argv) {
				//声明局部变量
				extern int x;
				//使用局部变量,变量y在执行函数的前面,不需要声明
				printf("%d %d\n",x,y);
				return EXIT_SUCCESS;
			}
			//初始化全局变量
			int x = 10;
		
		* 在函数内部使用全局变量,都建议先声明再使用

		* 全局变量未初始化,默认赋值为:0
		* 全局变量只能定义一次,可以声明多次
			#include <stdlib.h>
			#include <stdio.h>
			int main(int argc,char **argv) {
				extern int x;
				extern int x;
				extern int x;	//多次声明
				return EXIT_SUCCESS;
			}
			int x = 10;
			extern int a;
			extern int a;
			extern int a;		//多次声明
		
		* 全局变量的缺陷,如果定义一个全局变量,没有初始化的时候,无法确定是定义,还是声明
		* 声明,可以有多次,定义只有一次,'只要是赋值,就是定义,其他的都是声明'
			int x;int x;int x;	//x不知道哪个是定义,哪个是声明,这种语法在C语言是合法的,在C++是非法的
			int x = 10;			//有赋值,肯定是定义,其他地方只能是声明
		
		* 定义全局变量,建议初始化
		* 声明全局变量,建议添加:extern 关键字
			#include <stdlib.h>
			#include <stdio.h>
			int main(int argc,char **argv) {
				//声明全局变量
				extern int a;
				printf("%d",a);	//10
				return EXIT_SUCCESS;
			}
			//定义全局变量
			int a = 15;
			//声明全局变量
			extern int a;
	
	# extern 还可以用于函数声明(函数声明的 extern 可以省略不写)
		extern void func(int,char *);
	
	
	# 全局变量只能使用常量初始化
		int x = 5;
		size_t size = sizeof(x);
		int y = x * 5;		// error: initializer element is not constant
		int main(int argc, char **argv) {
			return EXIT_SUCCESS;
		}

		* 只要不是变成数组, sizeof 表达式可以被视为常量
	
	# 全局变量分文件
		* 不同文件,普通全局变量只能定义一次,可以声明多次

	# static 全局变量(内部链接)
		* 和普通全局变量的文件作用域不一样 
			* 普通的全局变量,在多个文件中,只能被定义一次,所有文件都能使用(需要先声明)
			* static 全局变量,可以在多个文件中被重复定义,因为,它只能当前文件使用,其他的文件无法使用
		
		* extern 只能用于普通的全局变量

----------------------------------------
普通函数与 static 函数					|
----------------------------------------
	# 普通函数和 static 函数的区别与 普通全局变量和 static 全局变量的区别是一样的
		* 普通函数,所有文件只能定义一次,所有文都可以使用
		* static 函数,只能在当前文件使用,所以多个文件,可以重复的定义相同的函数
	
---------------------------------------
总结									|
---------------------------------------
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
类型				作用域		生命周期		存储位置				  |
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
auto 变量			{}内		当前{}			栈
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
static 局部变量		{}内		整个程序运行期	初始化在data,未初始化在bss
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――	
extern 变量			整个程序	整个程序运行期	初始化在data,未初始化在bss
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
static 全局变量		当前文件	整个程序运行期	初始化在data,未初始化在bss
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
extern 函数			整个程序	整个程序运行期	代码区
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――	
static 函数			当前文件	整个程序运行期	代码区
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
register 变量		{}内		当前{}			运行时存储在CPU寄存器
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
字符串常量			当前文件	整个程序运行期	data
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
