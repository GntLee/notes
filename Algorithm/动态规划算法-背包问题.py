# 背包问题
	* 使用动态规划算法

	* 有一个背包, 容量为4磅, 现在有如下物品
		物品	重量	价格
		吉他(G)	1		1500
		音响(S)	4		3000
		电脑(L)	3		2000
	
	* 要求达到的目标是, 装入背包的总价值最大, 并且重量不能超出
	* 装入的物品不能重复(这是01背包问题)

	* 装入的物品可以重复(这事完全背包问题, 完全背包可以转换为01背包)


# 动态规划算法
	* 核心思想就是, 把大问题划分为小问题进行解决, 从而一步步获取最优的处理算法
	* 跟分治算法类似, 不同的是, 适合用于动态规划求解的问题, 经过分解得到的子问题往往不是相互独立的,
	* 也就是说, 下一个阶段的求解是建立在上一个子阶段的解的基础上, 进行进一步求解的
	* 动态规划可以通过填表的方式来逐步推进, 得到最优的解

# 代码实现


#物品的重量
w = [1, 4, 3]

# 物品的价值
val = [1500, 3000, 2000]

# 背包的容量
m = 4

# 物品的个数
n = len(val)

# 记录商品情况的二维数组
path = [[0 for i in range(m + 1)] for i in range(n + 1)]

# 创建二维数组
v = [[0 for i in range(m + 1)] for i in range(n + 1)]

# 初始化第一行和第一列为0, 其实不用处理, 因为初始化的时候已经全部默认设置为0了
# 把第1列设置为0
for arr in v:
    arr[0] = 0
# 把第1行设置为0
for i in range(len(v[0])):
    v[0][i] = 0

# 根据公式动态规划处理，不处理第一行
for i in range(1, len(v)):
    # 不处理第一列
    for j in range(1, len(v[0])):
        if w[i - 1] > j:
            v[i][j] = v[i - 1][j]
        else:
            # v[i][j] = max([v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]])
            if v[i - 1][j] < (val[i - 1] + v[i - 1][j - w[i - 1]]):
                v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]
                path[i][j] = 1
            else:
                v[i][j] = v[i - 1][j]
    
    
# 表
print('表---------------------------------------')
for i in v:
    print(i)


print('最终商品--------------------------------------')
# 最终结果
# for i, arr in enumerate(path):
#     for j in arr:
#         if j == 1:
#             print('第[%d]个商品放入了背包' % i)

i = len(path) - 1
j = len(path[0]) - 1

# 逆向遍历
while i > 0 and j > 0:
    if path[i][j] == 1:
        print('第[%d]个商品放入了背包' % i)
        j -= w[i - 1]
    i -= 1
    

