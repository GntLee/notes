----------------------------
内存的分配策略				|
----------------------------
	# 对象优先在 Eden 分配
		* 当 Eden 空间不足的时候, 会发起一次: Minor GC

	# 大对象, 直接进入老年代
		* 大对象, 指的是需要大量连续内存空间的对象(很长的字符串, 数组)
		* 如果经常出现大对象的话, 可能会导致内存还有不少空间, 但是不得不提前触发GC来获取足够的连续空间
		* 可控制参数: -XX:PretenureSizeThreshold

	# 长期存活的对象, 进入老年代
		* JVM给每个对象定义了一个年龄的计数器
		* 进过一次GC, 还存活的对象, 年龄+1
		* 年龄达到了一定的程度, 就会进入老年代, 默认 15 岁
		* 可控制参数: -XX:MaxTenuringThreshold
	
	# 动态对象年龄判定
		* JVM并不是需要对象的年龄必须到达了 MaxTenuringThreshold 后才能晋升到老年代
		* 在 Survivor 空间中, 相同年龄的所有对象的大小总和, 大于了 Survivor 的一半, 那么年龄大于或者等于该年龄的对象都直接进入老年代

		* 通俗的理解就是, 几个对象, 年龄相等, 而且 Survivor 内存已经耗了一半多了, 此时就会把这个年龄段的对象, 和大于该年龄的对象, 都放入老年代

	
	# 空间分配担保
		* 在发生 Minor GC 之前, JVM要检查老年代可用的最大连续空间是否大于新生代所有对象的总空间
			'我这空的地儿, 能不能装下你的所有对象'
		
		* 如果条件成立(能装下), 那么 Minor GC 是安全的, 直接执行就OK
		* 如果条件不成立(空闲的内存存不下所有的对象), 那么会判断一个值:-XX:HandlePromotionFailure
			* +HandlePromotionFailure	
				* 检查老年代可用的最大连续空间, 是否大于历次晋升到老年代对象(总大小)的平均大小
					* 大于
						* 尝试进行一次: Minor GC , 尽管这是有风险的
						* 取平均值是一种动态概率手段, 如果某次GC存活后的对象剧增, 远远高于平均值的话, 会导致担保失败
						* 在担保失败后, 会发起一次 Full GC

					* 小于
						* 执行 Full GC

			* -HandlePromotionFailure
				* 执行 Full GC
		
		
		* JDK6之后, HandlePromotionFailure 参数就没用了
		* 只要老年代连续的内存空间大于新生代所有对象总内存大小空间, 或者大于历次晋升到老年代对象(总大小)的平均大小, 就执行:Minor GC 
		* 否则, 就执行 Full GC
	
		


