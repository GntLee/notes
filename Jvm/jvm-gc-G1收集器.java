--------------------
G1 收集器			|
--------------------
	# 在JK9已经被设置为默认的收集器,面向大内存(Heap区数G到数10G), 多核系统的收集器,能够实现软停顿目标收集并且具有高吞吐量, 具有更可预测的停顿时间
		* Copying算法收集的分代的增量式收集器
		* 避免长暂停时间, 可以考虑将堆分成多个部分, 一次收集其中一部分, 这样的方式又叫做增量收集(incremental collection), 分代收集也可以看成一种特殊的增量收集


	# 它是目前收集器技术发展的前沿成果之一, 是一个面向服务端的GC收集器
		* 它的使命就是替换掉JDK5的CMS收集器
	
	# 特点
		1. 并行和并发
			* 并行收集, 充分发挥多核的优势, 缩短 STW 时间
			* 其他收集器需要暂停业务线程来完成收集工作, G1仍然可以通过并发让业务线程继续执行
		
		2. 分代收集
			* G1中仍然保留分代的概念,
			* 不需要其他的收集器配合, 自己就能管理好整个堆, 它采取不同的处理方式去管理不同的对象, 以达到更好的收集效果
				- 新创建的对象
				- 熬过了多次GC, 仍然存活的对象
			
		3. 空间整合
			* 与CMS的标记-清理算法不同, G1从整体来看是标记-整理算法, 从局部来看是基于复制算法实现的
			* 这两种算法都不回产生空间碎片, GC后能提供规整的可用内存, 非常利于程序的长时间运行, 分配大对象时不会因为找不到连续内存而提前触发下一次GC
		
		4. 可预测的停顿
			* 这是G1相对于CMS的又一个优势, 降低停顿时间是G1和CMS共同的关注点
			* G1除了追求低停顿后, 还能建立可预测的停顿时间模型,
			* 能够让使用者明确指定在一个长度M毫秒的时间段内, GC收集时间不能超过N毫秒
			* 这几乎已经是 Java(RTSJ) 实时垃圾收集器的特征
	
	# 参考
		https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection
		https://liuzhengyang.github.io/2017/06/07/garbage-first-collector/

--------------------
G1 内存模型			|
--------------------
	# 分区 Region
		* 堆内存划分为一系列大小相等的Region区域
		* Region大小在1MB到32MB在启动时确定
		* G1同样也使用分代收集策略, 将堆分为Eden, Survivior, Old等, 只不过是按照逻辑划分的, 可以不连续, 一个 Old Region 经过GC后可能成为新的 Eden
		* 当申请的对象大于Region大小的一半时, 会被放入一个Humongous Region(巨型区域)中
		* 当一个Region中是空的时, 称为可用Region或新Region

	# 卡片 Card
		* 512bytes表示一个card, cardtable就是一个byte数组


--------------------
G1 跨区域引用的问题	|
--------------------
	# G1之可以建立, 能预测的停顿时间模型, 是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集
		* 跟踪每一个 Region 里面的垃圾堆的价值大小(回收所获得的空间大小, 和回收所需的时间经验值)
		* 在后台维护了一个'优先列表', 每次根据允许收集的时间, 优先回收价值最大的 Region(Garbage-First名称就是这么来的)
		* 使用 Region 划分内存空间, 以及带优先级区域回收的方式, 保证了G1在有限时间内, 获取尽可能高的收集效率
	
	# 把内存化整为零的思想, 理解起来很容器, 但是实现的细节确比较难
		* 这东西从 2004 年提Sun实验室发表第一批G1论文到今天, 用了近10年的时间才鼓捣出来, 你说容易不容易

	# 跨 Region 引用的问题
		* 把堆分成了N个 Region, 垃圾收集的单位也不能完全的以 Region 进行
		* 因为一样对象, 分配在一个 Region 中, 它不仅可以被同一个 Region 的对象引用, 还可能被其他 Region 的对象引用
		* 在判断对象存活的时候, 岂不是还得扫描整个 Java 堆才能保证准确性

		* 这个问题并非G1才有, 只是在G1上显得更加的突出
		* 分代收集, 回收新生代中的对象, 也面临相同的问题, 可能老年代引用了新生代的对象
		* 回收新生代的时候, 也不得不扫描老年代的话, 那么 Minor GC 的效率就会下降不少
	
	# G1收集器里面, Region 之间的对象引用, 以及其他收集器中的新生代与老年代之间的对象引用, JVM使用:Remembered Set 来避免全堆扫描
		* G1里面, 每一个 Region 都有一个 Remembered Set
		* 虚拟机在程序对 Refrence 类型的数据写进行写操作的时候, 会产生一个 Write Barrier 暂时中断写操作

		* 检查 Refrence 引用的对象是否在不同的 Region 中
		* 如果是的话, 便通过: Card Table 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 中
		* 当进行GC的时候, 在GC根节点的枚举范围中加入: Remembered Set , 就不用对全堆扫描, 而且也不会有遗漏
			
	
		* 模拟一个过程
			// 1. 在写入引用对象的时候, 中断操作
				User user = new User();
				Book book = new Book();
				book.author = user;  //  Write Barrier
			// 2. 判断 user 是否不在 book 对象的 Region 中
			// 3. 如果不是在同一个 Region ,记录引用信息在 user 所属的 Region 的  Remembered Set 中
			// 4. 对 user 的 Region 进行回收的时候, 可以通过引用信息, 找到 book 对象的 Region

--------------------
G1 执行步骤			|
--------------------
	# 不计算维护 Remembered Set 的操作

	# 初始标记(Initial Marking)
		* 仅仅标记一下 GC Roots 能直接关联到的对象, 并且修改 TAMS(Next Top at Mark Start) 的值
		* 让下一个阶段用户程序并发的时候, 能在正确可用的 Region 中创建新对象
		* 这个阶段需要业务线程停顿, 但是耗时非常短,

	# 并发标记(Concurrent Marking)
		* 从GC Roots开始对堆中对象进行可达性分析, 找出存活的对象
		* 耗时比较长, 但是可以跟业务线程并发执行

	# 最终标记(Final Marking)
		* 修正上阶段中(并发标记), 因为业务线程继续执行而导致标记产生了变化的一部分记录
		* JVM把这段时间对象变化记录在线程 Remembered Set Logs 中
		* 在该阶段, 需要把 Remembered Set Logs 的数据合并到 Remembered Set 中,
		* 在该阶段, 需业务线程停顿, 但是可以并行执行

	# 筛选回收(Live Data Counting And Evacuation)
		* 首先对各个 Region 的回收价值和成本进行排序
		* 根据用户所期望的GC停顿时间来制定回收计划

		* Sun透露的信息来看, 这个阶段其实也可以做到与业务线程一起并发执行的
		* 但是因为只回收一部分的 Region, 时间是用户可以控制的, 而且停顿用户线程可以大幅度提高收集效率
	

	

--------------------
G1 相关的配置		|
--------------------
-Xms
-Xmx
	* 堆的初始化大小和最大大小

-XX:+UseG1GC
	* 启动G1收集器

-XX:MaxGCPauseMillis=200
	* GC最大暂停时间, 默认 200 毫秒

-XX:InitiatingHeapOccupancyPercent=45
	* 开始一个标记周期的堆占用比例阈值, 默认45%
	* 注意这里是整个堆, 不同于CMS中的Old堆比例

XX:G1HeapRegionSize
	* 设置每个Regin的大小,
	* 1MB到32MB的(2的指数的大小)




--------------------
G1 的GC日志			|
--------------------
	