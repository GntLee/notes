------------------------
类加载过程				|
------------------------
	# 加载
		* 类的加载阶段需要做3件事情

		1. 通过一个类的全限定名来获取定义该类的字节数据
			* 不仅仅是磁盘的class文件
			* 可以从ZIP包读取, (jar/war,ear)
			* 从可以网络读取,Applet
			* 运行时计算生成, Proxy 代理,就是使用: ProxyGenerator.generateProxyClass 来为特定的接口生成形式为"*$Proxy"的代理类字节数据
			* 可以由其他的文件生成, JSP, 通过JSP生成类
			* 可以从数据库读取
					
		2. 把这个字节数据代表的静态存储结构转换为方法区的运行时数据结构

		3. 在内存中生成一个代表该类的 Class 对象, 作为方法区访问这个类的各种数据的入口
			* Class 对象比较特殊, 虽然它是对象, 但是它是在方法区中的



		* 对于数组而言, 加载有所不同, 数组类本身不需要通过类加载器创建
		* 它是由jvm直接创建的, 但是数组类和类加载器还是有密切的关系, 因为数组的元素类型, 最终是要靠类加载器去创建
		* 一个数组的创建过程需要遵循的规则
			- 如果数组的类型(去掉一个维度后的类型), 是引用类型就采取上述的加载过程
			
			- 如果数组的类型不是引用类型(int[]), JVM会把数组标记为与引导加载器关联

	
	# 验证
		* 连接阶段的第一步
		* 验证的目的是为了确保 Class 文件的字节流中包含的信息符合当前JVM虚拟机的要求, 并且不会危害JVM的安全
		
		* 验证阶段大致会完成4个阶段的校验动作
			1. 文件格式验证
				* 是否以魔输:0xCAFEBABE 开头
				* 主,次版本号是否在当前JVM虚拟机的处理范围内
				* 常量池的常量是否头不被支持的常量类型(检查常量 tag 标志)
				* CONSTANT_Utf8_info, 型的常量中是否有不符合 utf8 编码的数据
				* Class 文件中各个部分及文件本身是否有被删除, 或者附加的其他信息
				* ... 更多

			2. 元数据验证
				* 是否有父类(除了 Object 外, 都应该有父类)
				* 是否继承了不允许被继承的类(final 修饰的类)
				* 如果类不是抽象类, 是否实现了其父类接口中的所有抽象方法
				* 类中的字段, 方法是否与父类产生矛盾(覆盖了父类的 final 字段, 或者出现了不符合规则的重载)

			3. 字节码验证

			4. 符合引用验证
				* 符号引用中通过字符串描述的全限定名, 是否能找到对应的类
				* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
				* 符号引用中的类, 字段, 方法的访问属性:private,protected,public,default 是否可以被当前类访问
			

	# 准备
		* 为变量分配内存, 并且设置类变量(static)初始值的阶段
		* 这些变量所使用的内存都会在方法区中进行分配

			public static int value = 123;

			* 在准备阶段, value的初始化值是0, 因为还没开始执行任何Java方法
			* 把value赋值为 123 的putstatic指令是在程序被编译后, 存放于类构造器 <cinit>() 方法中
		
		* 如果是 final 修饰的属性, 在准备阶段, 变量就会被初始化
			public static final int value = 123;

			* 准备阶段, jvm会把value初始化为 123
	
	# 解析
	
	# 初始化
		* 类加载的最后一步, 直到该阶段, 才真正开始执行类中定义的 Java 程序代码

		* <cinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作,和静态语句块中的语句合并产生的
		* 编译器的收集顺序, 是按照源代码文件中出现的顺序所决定的
		
		* static 代码块, 只能访问到定义在静态代码块之前的变量, 定义在之后的变量, 可以赋值, 但是不能访问
			class Foo {
				static {
					value = 10;					// 赋值正常
					System.out.println(value);// 访问异常：非法向前引用
				}
				public static int value = 0;
			}
		

		* JVM保证子类的 <cinit>() 执行之前, 父类的<cinit>() 已经执行完毕
		* 因此, 父类的 static 会先执行
		* 因此在JVM中第一个执行 <cinit>() 肯定是 Object

		* <cinit>() 对于接口来说并不是必须的, 如果一个类没有 static 代码块, 也没有对变量的赋值操作, 那么是可以不需要 <cinit>() 的
		
		* <cinit>() 的初始化过程是线程安全的, 类加载的过程是线程安全的
	

