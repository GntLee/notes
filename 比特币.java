
# 一个区块大约 1024KB(1MB), 大约存储 4000 条左右的交易记录
	+---------+------------------
	|区块头	  |	信息
	+---------+------------------

# 为什么要记账?
	* 记账, 是有手续费的, A 转账给 B, 负责打包信息的人可以获取到一定的手续费, 手续费是 A 负责给
	* 10 分钟可以打包一次
	* 打包的人, 有打包奖励(中本聪的设计, 每4年, 奖励减半)
		- 最开始打包的人, 一次打包可以获取到 50 个比特币的奖励
		- 4年以后, 一次打包可以获取到 25 个比特币
		- 4年以后, 一次打包可以获取到 12.5 个比特币
	
	* 根据这个设计比特币一共只有 2100 W个

# 解决账单问题, 以谁为准?
	* 打包只能是一个人打包, 具体是谁打包, 根据中本聪的设计, 使用:工作量证明方法

	* 每个参与的用户都要去计算一道非常难的数学题:挖矿
	* 如果你做出来了, 那么你就可以有权利打包, 从而获取到手续费, 打包奖励


# 挖矿, 到底是啥数学题?
	* 哈希函数(SHA256), 正向计算比较容易, 逆向运算非常困难
	* 根据hash逆向出结果, 只能一个个去试
	
		let data =  前一块的头部 + 账单的信息 + 时间戳 + 随机数
		let result = SHA256(SHA256(data))

		* 要求计算结果的前n位都是0(bit)
			* n 越大,难度越高,n越小,难度越低, 是怎么确定这个n的?
			* 中本聪的设计, 每10分钟出一个块儿, 打包几千条信息, 就是通过调整这个 n 来保证的


		* 如果ok, 这个结果就是新的一个区块, 链接到上一个区块之后
		
		* 整个过程只能不断的去修改随机数,其他的数据不能修改
		* 随机数从 0 开始递增

# 记录防伪?
	*  A 付款10比特币给 B

		1. A打包数据->	付款信息 -> (SHA256) -> RSA私钥 = 密码
				密码 = RSA私钥加密(SHA256(付款信息))

		2. 全网广播(付款信息 + RSA公钥 + 密码)

		3. 付款信息 -> (SHA256) -> RSA公钥 = 密码
				密码 = RSA公钥解密(SHA256(付款信息))

		4. 对比步骤 2 和 3 的密码是否相同, 如果相同, 则是合法的
		

# 防止双重支付?
	* 区块链把很多交易信息,打包形成一个区块的链条
	* 防止支付余额不足的方法, 就是: 追溯

	* 从区块中找到你收获的一个比特币开始, 到现在计算你目前账户应该有多少余额
	* 从而判断当前的这次交易是否可以被确认, 如果可以就可以打包为新的区块
	

# 伪造记录?
	* 比特币有个最长链的原则, 区块链最长的记录, 被全网接受

	* 理论上来说, 你伪造的记录链长度, 必须要超过全网的区块链长度, 就可以认为是伪造成功了

	* 除非你拥有的计算能力, 超过了全网

# 保密?