------------------------
几种更新策略			|
------------------------
	# 先更新数据库, 再更新缓存

	# 先删除缓存, 再更新数据库
		
	# 先更新数据库, 再删除缓存

	# 先更新缓存, 再更新数据库
		* 绝不能用
		* 缓存更新成功, 但是DB更新失败数据回滚了, 缓存中就是脏数据
		* 没并发都容易导致脏数据的模式


------------------------
先更新数据库, 再更新缓存|
------------------------
	# 一般没人用, 存在2个问题
		1. 线程的安全问题
			* 同时有请求A和请求B进行更新操作, 那么会出现
			(1)线程A先更新了数据库
			(2)线程B又新了数据库
			(3)线程B先更新了缓存
			(4)线程A又更新了缓存
			
			* 请求A更新缓存应该比请求B更新缓存早才对, 但是因为网络等原因,B却比A更早更新了缓存(导致缓存被旧数据覆盖)
			* 这就导致了脏数据, 因此不考虑

		2. 写多读少的场景问题
			* 写数据库场景比较多, 而读数据场景比较少的业务场景, 采用这种方案就会导致:数据没怎么被读取, 缓存就被频繁的更新, 浪费性能
			* 如果写入缓存的数据, 并不是简单的读取存入, 而是要经过计算获取的情况下, 因为写多读少, 每次更新都去执行一次计算, 更是非常的浪费性能

			* 做不到延迟加载的效果, 只有第一次读取的时候才计算缓存才是合理的, 而不是每次更新都去计算
	
	# 线程安全问题的解决方案:
		* CAS算法, 可以给数据添加一个版本号, 每次执行更新 +1
		* 执行更新缓存的时候, 如果缓存的版本号比记录的版本号大, 则不执行更新
	
------------------------
先删除缓存, 再更新数据库|
------------------------
	# 该方案会导致不一致的原因:
		(1)请求A进行写操作,删除缓存
		(2)请求B查询发现缓存不存在
		(3)请求B去数据库查询得到旧值
		(4)请求B将旧值写入缓存
		(5)请求A将新值写入数据库

		* 因为A的数据库更新请求在写入缓存后执行了, 该值是一个脏数据, 如果缓存没过期时间的话, 这更为可怕	
	
	# 解决1:
		* 先删除缓存, 再更新数据库, 再回写缓存(出现策略一的情况)
	
	# 解决2:
		* 先删除缓存, 再更新数据库, 再删缓存(双删, 第二次删可异步)
	
	# 解决3:
		* 设置缓存的过期时间
		* 缓存有效时间短, 容易发生一段时间内缓存大量失效, 此时的数据库压力突然剧增, 引发缓存雪崩现象
		* 缓存有效时间为随机值减少发生缓存雪崩的可能性
	
------------------------
先更新数据库, 再删除缓存|
------------------------
	# 老外提出了一个缓存更新套路,名为: Cache-Aside pattern (缓存加持策略??)
		* 失效:应用程序先从cache取数据, 没有得到, 则从数据库中取数据, 成功后, 放到缓存中
		* 命中:应用程序从cache中取数据, 取到后返回
		* 更新:先把数据存到数据库中, 成功后, 再让缓存失效

		* 据说facebook也是这个策略?
	
	
	# 并发问题:
		(1)缓存不存在(刚好失效)
		(2)请求A查询数据库, 得一个旧值
		(3)请求B执行修改,将新数据写入数据库
		(4)请求B执行删除缓存(缓存此刻还不存在)
		(5)请求A将查到的旧值写入缓存
			
		* 因为请求A的写入缓存操作(5),在B更新后的删除操作之后(4), 导入了写入缓存的数据是脏数据
		* 根本的原因就是因为: 读比写耗时导致的
		* 实际上数据库的读操作的速度远快于写操作的,不然做读写分离干嘛, 所以这一情形很难出现
	
	# 并发导致脏数据的解决方案:设置缓存的过期时间

	# 缓存删除失败的问题:
		* 数据库更新成功, 但是缓存删除失败, 导致了缓存里面是脏数据

	# 缓存删除失败的问题的解决方案: 删除队列
		1. 尝试执行缓存的删除
		2. 如果删除失败, 则添加到队列
		3. 轮询队列, 尝试删除
		4. 还是删除失败, 则重复执行步骤 2
	
		* 缺点
			* 引入中间件(Queue/MQ), 增加复杂度
			* 对业务线代码造成大量的侵入
	
	# 缓存删除失败的问题的解决方案: 订阅DB的 binlog 
		* 启动一个订阅程序(应用)去订阅数据库的binlog, 获得需要操作的数据
		* 在应用中进行删除操作
	
		* mysql中有现成的中间件叫canal, 可以完成订阅binlog日志的功能

	