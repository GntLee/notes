----------------------------
输入与输出					|
----------------------------
	# 文件描述符
		* 文件描述符是一个非负整数,可以唯一标识会话中打开的文件
		* 每个进程一次最多可以有九个文件描述符
		* 出于特殊的目的,bash shell保留了三个文件描述符
			0 STDIN
			1 STDOUT
			2 STDERR
	
		* 重定向错误信息
			2>
		
		* 重定向正常消息和错误消息
			&>
		
----------------------------
在脚本中重定向输出			|
----------------------------
	# 有意在脚本中生成错误消息，可以将单独的一行输出重定向到 STDERR : >&2 

	# 在脚本中临时重定向输出
			echo "异常信息" >&2

		* 默认情况下,Linux会将 STDERR 导向 STDOUT 
		* 如果在运行脚本时重定向了STDERR ,脚本中所有导向 STDERR 的文本都会被重定向

			echo "这是一个异常消息" >&2
			echo "这是一个正常消息"

			./demo.sh 2> log # 

			*  STDOUT 显示的文本显示在了屏幕上,而发送给 STDERR 的 echo 语句的文本则被重定向到了输出文件
	
	# 在脚本中永久重定向
		* 如果脚本中有大量数据需要重定向,那重定向每个 echo 语句就会很烦琐
		* 可以用 exec 命令告诉shell在脚本执行期间重定向某个特定文件描述符
			exec 1>file

			1:表示STOUT
			file:重定向的文件

		* exec 命令会启动一个新shell并将 STDOUT 文件描述符重定向到文件
		* 脚本中发给 STDOUT 的所有输出会被重定向到文件
		* 可以在脚本执行过程中重定向回 STDOUT 
	
----------------------------
在脚本中重定向输入			|
----------------------------
	# 使用与脚本中重定向 STDOUT 和 STDERR 相同的方法来将 STDIN 从键盘重定向到其他位置
		* exec 命令允许将 STDIN 重定向到Linux系统上的文件中

		exec 0<file
	
	# 读取文件
		exec 0<demo.sh	# 重定向了标准输入到文件
		while read line ; do	# 默认read读取的是标准输入
			echo "$line"
		done

----------------------------
创建自己的重定向输出		|
----------------------------
	# 在脚本中重定向输入和输出时,并不局限于这3个默认的文件描述符
		* shell中最多可以有9个打开的文件描述符
		* 其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向
		* 可以将这些文件描述符中的任意一个分配给文件,然后在脚本中使用它们

	# 创建文件描述符
		* 用 exec 命令来给输出分配文件描述符,和标准的文件描述符一样
		* 一旦将另一个文件描述符分配给一个文件,这个重定向就会一直有效,直到你重新分配

		exec 3>file				# 把文件描述符3分配给了file这个文件
		echo "这是消息" >&3		# 把echo的内容由标准输出重定向到3
	
	# 重定向时仅仅追加,不覆盖
		exec 3>>file

	# 重定向文件描述符
		exec 3>&1			# 把3重定向到标准输出
		exec 1>test14out	# 把标准输出重定向到文件

	
	# 创建输入文件描述符
		* 可以用和重定向输出文件描述符同样的办法重定向输入文件描述符
		* 在重定向到文件之前,先将 STDIN 文件描述符保存到另外一个文件描述符
		* 然后在读取完文件之后再将 STDIN 恢复到它原来的位置
		
		exec 6<&0			# 把标准输入重定向到6
		exec 0< testfile	# 把文件重定向到标准输入
	
	# 创建读写文件描述符
		* 用这种方法时,要特别小心
		* 对同一个文件进行数据读写,shell会维护一个内部指针,指明在文件中的当前位置
		* 任何读或写都会从文件指针上次的位置开始
		* 所以这操作,可能会导致数据被覆盖

		exec 3<> testfile
	
	# 关闭文件描述符
		* 建了新的输入或输出文件描述符,shell会在脚本退出时自动关闭它们
		* 有些情况下,你需要在脚本结束前手动关闭文件描述符
		* 要关闭文件描述符,将它重定向到特殊符号 &- 
			exec 3>&-

			* 关闭文件描述符3,不再在脚本中使用它

		* 如果尝试使用已经关闭的文件描述符会有异常:Bad file descriptor
		* 关闭文件描述符时还要注意另一件事,如果随后在脚本中打开了同一个输出文件
		* shell会用一个新文件来替换已有文件,这意味着如果你输出数据,它就会覆盖已有文件

----------------------------
列出打开的文件描述符		|
----------------------------
	# lsof 命令会列出整个Linux系统打开的所有文件描述符
		* 这是个有争议的功能
		* 因为它会向非系统管理员用户提供Linux系统的信息
		* 鉴于此,许多Linux系统隐藏了该命令,这样用户就不会一不小心就发现了
		* 很多Linux系统中(如Fedora), lsof 命令位于/usr/sbin目录,要想以普通用户账户来运行它,必须通过全路径名来引用
			/usr/sbin/lsof

			* 该命令会产生大量的输出,它会显示当前Linux系统上打开的每个文件的有关信息
			* 这包括后台运行的所有进程以及登录到系统的任何用户

			/usr/sbin/lsof -a -p $$ -d 0,1,2

			-a:对其他两个结果进 & 运算
			-p:指定pid($$为shell的pid)
			-d:显示的文件描述符编号
			0,1,2:默认文件描述符


----------------------------
阻止命令输出				|
----------------------------
	# 可能不想显示脚本的输出,这在将脚本作为后台进程运行时很常见
	# 可以把输出重定向到 /dev/null
		ls > /dev/null
	
	# 快速的清空文件
		cat /dev/null > file


----------------------------
创建临时文件				|
----------------------------
	# Linux使用/tmp目录来存放不需要永久保留的文件
	# 大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件
	
	# 有个特殊命令可以用来创建临时文件, mktemp 命令可以在/tmp目录中创建一个唯一的临时文件
		* shell会创建这个文件,但不用默认的 umask 值
	
	# 创建本地临时文件
		*  mktemp 会在本地目录中创建一个文件
		* 要用 mktemp 命令在本地目录中创建一个临时文件,只要指定一个文件名模板就行了
		* 模板可以包含任意文本文件名,在文件名末尾加上6个 X 就行了
			mktemp testing.XXXXXX
		
		* mktemp 命令会用6个字符码替换这6个 X ,从而保证文件名在目录中是唯一的
	
	# 在脚本中使用 mktemp 命令时,可能要将文件名保存到变量中,这样就能在后面的脚本中引用了
		tempfile=$(mktemp test19.XXXXXX)
		exec 3>$tempfile
	
	# 在/tmp 目录创建临时文件
		* -t 选项会强制 mktemp 命令来在系统的临时目录来创建该文件
		* mktemp 命令会返回用来创建临时文件的全路径,而不是只有文件名


	# 创建临时目录
		* -d 选项告诉 mktemp 命令来创建一个临时目录而不是临时文件
	
----------------------------
记录消息					|
----------------------------
	# 将输出同时发送到显示器和日志文件,这种做法有时候能够派上用场
	# 你不用将输出重定向两次,只要用特殊的 tee 命令就行
		tee file
		
		* 它就像是一个一个T形的管道,可以同时往STDOUT和文件输出数据

	#  tee 会重定向来自 STDIN 的数据,可以用它配合管道命令来重定向命令输出
		date | tee testfil	# 会在屏幕输出,还会输出到文件

	
	#  tee 命令会在每次使用时覆盖输出文件内容
		* 如果你想将数据追加到文件中,必须用 -a 选项
		date | tee -a testfile
	
	# demo
		tempfile=/usr/local/temp
		echo "This is the start of the test" | tee $tempfile
		echo "This is the second line of the test" | tee -a $tempfile
		echo "This is the end of the test" | tee -a $tempfile


